<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cafra.github.io/</id>
    <title>cafra</title>
    <updated>2020-05-08T13:46:53.961Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cafra.github.io/"/>
    <link rel="self" href="https://cafra.github.io/atom.xml"/>
    <subtitle>Reading, practice, reflection, sharing, innovation</subtitle>
    <logo>https://cafra.github.io/images/avatar.png</logo>
    <icon>https://cafra.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cafra</rights>
    <entry>
        <title type="html"><![CDATA[context 使用、原理、遇到问题]]></title>
        <id>https://cafra.github.io/post/context-shi-yong-yuan-li-yu-dao-wen-ti/</id>
        <link href="https://cafra.github.io/post/context-shi-yong-yuan-li-yu-dao-wen-ti/">
        </link>
        <updated>2020-05-08T00:59:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>多链路调用超时控制</li>
<li>多routine 超时控制</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[语言系列-Golang]]></title>
        <id>https://cafra.github.io/post/yu-yan-xi-lie-golang/</id>
        <link href="https://cafra.github.io/post/yu-yan-xi-lie-golang/">
        </link>
        <updated>2020-05-07T13:44:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pprof-原理">pprof 原理</h1>
<ul>
<li>取样
<ul>
<li>让操作系统把计时器抽象出来，给程序发SIGALRM信号，然后由用户层去处理计时器取样</li>
</ul>
</li>
<li>统计
<ul>
<li>对栈帧进行取样，获取函数调用的链路；</li>
</ul>
</li>
</ul>
<h1 id="goroutine-并发控制">goroutine 并发控制</h1>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局共享变量(cas)</td>
<td>简单</td>
<td>无法安全退出</td>
<td>状态机</td>
</tr>
<tr>
<td>channel+waitgroup</td>
<td>简单，可以安全退出</td>
<td></td>
<td>运行框架控制</td>
</tr>
<tr>
<td>context+waitgroup</td>
<td>强并发控制 goroutine 间通信，结合了Mutex锁(需要保证goroutine并发安全)和channel而实现的</td>
<td></td>
<td>并发通信</td>
</tr>
</tbody>
</table>
<ul>
<li>共享变量示例代码</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync/atomic&quot;
	&quot;time&quot;
)

const (
	EStatusStop = iota
	EStatusRun
)

var (
	Status int32 = EStatusRun
)

func main() {
	go func() {
		for i := 0; i &lt; 10; i++ {
			go echo(i)
		}
	}()

	time.Sleep(5 * time.Second)
	atomic.StoreInt32(&amp;Status, EStatusStop)

	time.Sleep(time.Second)
	fmt.Println(&quot;main exit&quot;)
}

func echo(id int) {
	for {
		fmt.Printf(&quot;Id=%v say hello\n&quot;, id)
		time.Sleep(time.Second)
		if EStatusStop == atomic.LoadInt32(&amp;Status) {
			fmt.Printf(&quot;Id=%v exit\n&quot;, id)
			return
		}
	}
}

</code></pre>
<ul>
<li>channel +waitgroup</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;os/signal&quot;
	&quot;sync&quot;
	&quot;syscall&quot;
	&quot;time&quot;
)

func main() {
	stop := make(chan bool)
	var wg sync.WaitGroup

	for i := 0; i &lt; 3; i++ {
		wg.Add(1)
		go func(id int, c chan bool) {
			defer wg.Done()
			consumer(id, c)
		}(i, stop)
	}
	waitForSignal()
	// close channel,all receiver can get close signal
	close(stop)
	wg.Wait()
	fmt.Println(&quot;main exit&quot;)
}

// &lt;-chan ：chan 输出，对应调用者是输入
// chan&lt;- : chan 输入，对应调用者是输出
func consumer(id int, stop &lt;-chan bool) {
	for {
		select {
		case &lt;-stop:
			fmt.Printf(&quot;id=%v comsumer stop\n&quot;, id)
			return
		default:
			fmt.Printf(&quot;Id=%v hello world\n&quot;, id)
			time.Sleep(time.Second)
		}
	}
}

func waitForSignal() {
	sigs := make(chan os.Signal)
	signal.Notify(sigs, os.Interrupt)
	signal.Notify(sigs, syscall.SIGTERM)
	signal.Notify(sigs, syscall.SIGTSTP)
	signal.Notify(sigs, syscall.SIGQUIT)
	&lt;-sigs
}

</code></pre>
<ul>
<li>context 传递参数 和取消</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;crypto/md5&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

const CtxUrlKey = &quot;url&quot;

func main() {
	addrs := []string{
		&quot;https://baidu.com&quot;,
		&quot;https://www.cmcm.com&quot;,
	}

	ctx, _ := context.WithTimeout(context.TODO(), 3*time.Second)
	var wg sync.WaitGroup

	for _, addr := range addrs {
		wg.Add(1)

		go GetUrl(context.WithValue(ctx, CtxUrlKey, addr), &amp;wg)
	}

	wg.Wait()

	fmt.Println(&quot;main exit&quot;)
}

/**
 * ctx 传递参数和超时通知
 *
 * param: context.Context ctx
 * param: *sync.WaitGroup wg
 */
func GetUrl(ctx context.Context, wg *sync.WaitGroup) {
	defer wg.Done()
	url := ctx.Value(CtxUrlKey).(string)
	for {
		select {
		case &lt;-ctx.Done():
			fmt.Printf(&quot;url=%v exit\n&quot;, url)
			return
		default:
			rsp, err := http.Get(url)
			if err != nil {
				fmt.Printf(&quot;get url=%v err=%v\n&quot;, url, err)
				break
			}

			bs, err := ioutil.ReadAll(rsp.Body)
			if err != nil {
				fmt.Printf(&quot;ReadAll url=%v body err=%v\n&quot;, url, err)
				return
			}
			rsp.Body.Close()
			fmt.Printf(&quot;get url rsp md5=%x\n&quot;, md5.Sum(bs))
		}
	}
}

</code></pre>
<h1 id="channel-原理">channel 原理</h1>
<h1 id="waitgroup的原理">WaitGroup的原理</h1>
<h2 id="参考链接">参考链接：</h2>
<ul>
<li>并发 https://blog.csdn.net/u013029603/article/details/81232395</li>
<li>grpc context 超时控制 https://blog.csdn.net/u013029603/article/details/81232395</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web 框架相关]]></title>
        <id>https://cafra.github.io/post/web-kuang-jia-xiang-guan/</id>
        <link href="https://cafra.github.io/post/web-kuang-jia-xiang-guan/">
        </link>
        <updated>2020-05-07T05:41:34.000Z</updated>
        <content type="html"><![CDATA[<h1> gin 源码 </h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ID生成器的原理]]></title>
        <id>https://cafra.github.io/post/id-sheng-cheng-qi-de-yuan-li/</id>
        <link href="https://cafra.github.io/post/id-sheng-cheng-qi-de-yuan-li/">
        </link>
        <updated>2020-05-06T00:49:16.000Z</updated>
        <content type="html"><![CDATA[<p>高效生成趋势有序的全局唯一ID，兼顾有序性、高性能、可扩展<br>
SnowFlake原理:</p>
<ol>
<li>64位的整型;</li>
<li>1位：标识部分;</li>
<li>41位：时间戳部分，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值; 2^41 /年毫秒数=69年</li>
<li>10位：节点部分，前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；根据实际情况设置；</li>
<li>12位：序列号部分，支持同一毫秒内同一个节点可以生成4096个ID；</li>
<li>生成的ID,可以通过转62进制，准换成字母数字的10位长字符串；</li>
</ol>
<p>UUID：</p>
<ol>
<li>可以在本地产生全局唯一的ID,但不能保证递增，不适合数据主键；</li>
</ol>
<p>数据库自增主键：</p>
<ol>
<li>可以保证递增。但是无法分库分表；</li>
<li>即使修改步长，进行分库，也不方便集群伸缩；</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消息队列]]></title>
        <id>https://cafra.github.io/post/xiao-xi-dui-lie/</id>
        <link href="https://cafra.github.io/post/xiao-xi-dui-lie/">
        </link>
        <updated>2020-05-05T15:52:25.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>消息队列概述</p>
</li>
<li>
<p>组成</p>
</li>
<li>
<p>作用</p>
</li>
<li>
<p>应用场景：</p>
<ol>
<li>异步解耦</li>
<li>削峰</li>
<li>顺序保证</li>
<li>缓冲</li>
</ol>
</li>
<li>
<p>协议</p>
</li>
<li>
<p>常见中间件</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kafka</td>
<td>高吞吐、持久化、partition 有序，多broker 备份，写hash 保证多patition 有序,单机并发10w/s</td>
</tr>
<tr>
<td>nsq</td>
<td>内存，高吞吐，不保证顺序，没有备份机制</td>
</tr>
<tr>
<td>rocket MQ</td>
<td>并发w/s，支持事务，仅支持java</td>
</tr>
<tr>
<td>rabitMQ</td>
<td>并发w/s，支持事务，支持多语言，标准消息队列协议，通用性好</td>
</tr>
<tr>
<td>redis</td>
<td>高吞吐，没有组概念</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>消息队列的最终一致性：</p>
<ol>
<li>使用带有事务的消息队列；</li>
<li>仿照思路：预写，确认，发送，预写check 的思路，实现一个；</li>
</ol>
</li>
<li>
<p>kafka 文件存储原理：todo</p>
</li>
</ol>
<p>参考文章：<br>
https://juejin.im/post/5d8882bdf265da03c9273821</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis 数据类型]]></title>
        <id>https://cafra.github.io/post/redis-shu-ju-lei-xing/</id>
        <link href="https://cafra.github.io/post/redis-shu-ju-lei-xing/">
        </link>
        <updated>2020-05-05T09:03:43.000Z</updated>
        <summary type="html"><![CDATA[<p>数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>名字</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>列表</td>
<td>ziplist 、linkedlist</td>
</tr>
<tr>
<td>hash</td>
<td>哈希表</td>
<td>ziplist、hashmap</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
<td>SDS</td>
</tr>
<tr>
<td>set</td>
<td>集合</td>
<td>IntSet</td>
</tr>
<tr>
<td>sorted set</td>
<td>有序集合</td>
<td>skiplist</td>
</tr>
</tbody>
</table>
]]></summary>
        <content type="html"><![CDATA[<p>数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>名字</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>列表</td>
<td>ziplist 、linkedlist</td>
</tr>
<tr>
<td>hash</td>
<td>哈希表</td>
<td>ziplist、hashmap</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
<td>SDS</td>
</tr>
<tr>
<td>set</td>
<td>集合</td>
<td>IntSet</td>
</tr>
<tr>
<td>sorted set</td>
<td>有序集合</td>
<td>skiplist</td>
</tr>
</tbody>
</table>
<!-- more -->
<ol>
<li>SDS = simple dynamic string 简单动态字符串；string类型<br>
<img src="https://cafra.github.io//post-images/1588669765666.png" alt="" loading="lazy"></li>
<li>双向链表：list类型
<ol>
<li>即可用作栈，也可以做队列；</li>
<li>包含head tail 指针，list 长度；</li>
<li>void * 万能指针，实现多台；<br>
<img src="https://cafra.github.io//post-images/1588670020175.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>字典：Hash 类型，set 集合
<ol>
<li>数据结构<br>
<img src="https://cafra.github.io//post-images/1588684312574.png" alt="" loading="lazy"></li>
<li>哈希算法：
<h1 id="使用字典设置的哈希函数计算键-key-的哈希值">使用字典设置的哈希函数，计算键 key 的哈希值</h1>
hash = dict-&gt;type-&gt;hashFunction(key);
<h1 id="使用哈希表的-sizemask-属性和哈希值计算出索引值">使用哈希表的 sizemask 属性和哈希值，计算出索引值</h1>
<h1 id="根据情况不同-htx-可以是-ht0-或者-ht1">根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</h1>
index = hash &amp; dict-&gt;ht[x].sizemask;<br>
当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。MurmurHash 算法目前的最新版本为 MurmurHash3 ；</li>
</ol>
</li>
<li>跳跃表：sortedset 有序集合类型，性能和红黑树类似
<ol>
<li>链表加多级索引的结构，就是跳表, 实现二分查找；所以时间复杂度logN;</li>
<li>索引数量是a1=n/2 ,an=2,q=1/2 所以，Sn=(a1-anq)/1-q=n-1 ,即空间复杂度O(n)；</li>
<li>有序链表，插入需要查找，所以O(logN)；删除O(logN)</li>
</ol>
</li>
<li>整数集合；set 类型；
<ol>
<li>有序数组，整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ol>
</li>
<li>压缩列表（ziplist）；
<ol>
<li>是列表键和哈希键的底层实现之一；</li>
</ol>
</li>
<li>对象：<br>
<img src="https://cafra.github.io//post-images/1588689799373.png" alt="" loading="lazy">
<ol>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 到 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。</li>
</ol>
</li>
<li>数据库：<br>
1.</li>
</ol>
<!-- more -->
<p>原始文章：<br>
https://mp.weixin.qq.com/s?__biz=MzI5NzAzOTM4MQ==&amp;mid=2648093049&amp;idx=1&amp;sn=9274af76149189ba4f5e45cd55308f15&amp;chksm=f4993203c3eebb15b380b9ee314ed1e3b580ba5303208be5fc57c34fa86b27d99ae7b14fadb3#rd</p>
<p>https://www.jianshu.com/p/c706d050d2f8</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql 原理]]></title>
        <id>https://cafra.github.io/post/mysql-update-zhi-xing-guo-cheng/</id>
        <link href="https://cafra.github.io/post/mysql-update-zhi-xing-guo-cheng/">
        </link>
        <updated>2020-05-05T02:50:53.000Z</updated>
        <summary type="html"><![CDATA[<h1> update 执行过程 </h1>]]></summary>
        <content type="html"><![CDATA[<h1> update 执行过程 </h1>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://cafra.github.io//post-images/1588647116759.png" alt="" loading="lazy"></figure>
<p>事务提交2个阶段如何保证一致性；或者说是如何恢复的？<br>
crash 重启后：</p>
<ol>
<li>代开redo log 和系统表空间文件IbdataN</li>
<li>找到最新Checkpoint ，扫描redo log 即处于prepare 状态的redo log</li>
<li>如果在bin log 存在记录，则commit ,否则rollback事务；</li>
</ol>
<p>事务隔离级别：</p>
<ol>
<li>read uncommited = ru ；B session 未提交，A可以读到；赃读</li>
<li>read commited = rc    ；B session 提交后，A可以读到；</li>
<li>repeatable read= rr     ；B session 提交，不影响A 的数据；但可能幻读（增删）</li>
<li>serializable 串行          ；不存在：赃读、不可重复读、幻读问题；效率最低</li>
</ol>
<h1> 索引相关 </h1>
<p>数据一致性：</p>
<ol>
<li>数据库4个特性：原子性，一致性，隔离性、持久性</li>
<li>接口幂等方法：
<ol>
<li>数据库唯一索引；</li>
<li>token 一次性机制；</li>
<li>数据库悲观锁；</li>
<li>数据库乐观锁；</li>
<li>分布式锁：redis 、zookeeper，等</li>
<li>接口参数幂等：source来源，seq序列号</li>
<li>业务流程状态机；</li>
<li>异步+幂等；</li>
</ol>
</li>
</ol>
<p>索引设计原则：</p>
<ol>
<li>where group order，关联查询 列可以添加索引；</li>
<li>索引要适当，否则影响cud 性能；</li>
<li>在区分度高的字段建索引，否则没有效果，即过度索引；</li>
<li>唯一索引比不同索引性能要高；</li>
<li>字段尽量不要null，否则可能全表扫描；</li>
<li>多列索引：最左原则，注意使用顺序，尽量区分度高的放在左边</li>
<li>避免隐式转换；</li>
<li>where 中避免使用函数；</li>
<li>明确select 的字段；</li>
<li>禁止负向查询，not in, !=,&lt;&gt;,!&lt;,!&gt;,not like</li>
<li>缩小结果集，再join；</li>
<li>like %xx 匹配，无法使用索引；</li>
<li>or 导致索引失效；</li>
<li>串列需要前缀索引，提高查询速度；</li>
</ol>
<p>联合索引及其使用：</p>
<ol>
<li>最左原则；注意索引顺序；</li>
</ol>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键</td>
<td>唯一，不能为空，表唯一，hash 索引，准确查找，叶子节点存放的是整行数据，属于聚簇索引</td>
</tr>
<tr>
<td>唯一</td>
<td>唯一，可以为空，可以多个 ，hash/btree 索引，叶子节点存放的是主键的值，属于二级索引，效率低于主键索引</td>
</tr>
</tbody>
</table>
<h1> 数据库事务原理 </h1>
<h1> 数据库锁原理 </h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[幸福的成长]]></title>
        <id>https://cafra.github.io/post/xing-fu-de-cheng-chang/</id>
        <link href="https://cafra.github.io/post/xing-fu-de-cheng-chang/">
        </link>
        <updated>2020-03-28T16:00:38.000Z</updated>
        <content type="html"><![CDATA[<p>一直想记录一下孩子的成长过程。现在是北京时间2020年3月28日，由于新冠疫情不能回家看孩子，所以，记录了一下妮妮成长的点点滴滴。🇨🇳</p>
<p><img src="https://cafra.github.io//post-images/1585412166288.jpeg" alt="" loading="lazy"><br>
刚出生时的样子:孩子出生前一段时间，我从北京赶回母校，参加毕业答辩。答辩结束后，便匆忙地回到了老家南阳，看着老婆，心里说不出的愧疚，最终陪着她去了医院，妮妮出生了，出生时7斤6两，小胖姑娘。💃<br>
<img src="https://cafra.github.io//post-images/1585412415546.jpeg" alt="" loading="lazy"><br>
孩子满月的时候，我匆忙从北京赶回南阳，短暂的相聚，我又匆忙的回京。媳妇在我家受了很多苦，因为环境的不适应，丈母娘也来照顾老婆孩子了。<br>
<img src="https://cafra.github.io//post-images/1585412597479.jpeg" alt="" loading="lazy"><br>
不知不觉，孩子已经百天了，这次我没能赶回去，媳妇带着孩子回温县丈母娘家，因为没有车，这次是乘坐大巴回去的，路上吃了很多苦。在温县排了一组百天照片。<br>
<img src="https://cafra.github.io//post-images/1585412746008.jpeg" alt="" loading="lazy"><br>
孩子都长成弥勒佛了，傻乎乎的。但很可爱。我的鼻子突然酸了。<br>
<img src="https://cafra.github.io//post-images/1585412871225.jpeg" alt="" loading="lazy"><br>
抽时间回丈母娘家，看老婆孩子，孩子长了不少，穿着奶奶做的睡衣，感觉孩子精神很好。有点呆萌。<br>
<img src="https://cafra.github.io//post-images/1585413020768.jpeg" alt="" loading="lazy"><br>
这是孩子2~3岁时，我回家带孩子去游泳池玩耍，孩子开心极了，仿佛整个世界都融化了。看着孩子这么开心，心里说不出的喜悦。<br>
<img src="https://cafra.github.io//post-images/1585413167140.jpeg" alt="" loading="lazy"><br>
洗完澡，给孩子穿衣服，趁着孩子吃酸奶，拍了一张，留个纪念。<br>
<img src="https://cafra.github.io//post-images/1585413249449.jpeg" alt="" loading="lazy"><br>
孩子上小班了，穿着迷彩服的样子，好萌好可爱。<br>
<img src="https://cafra.github.io//post-images/1585413306141.jpeg" alt="" loading="lazy"><br>
这应该孩子妈妈带着她去郑州的游乐园玩时拍的，孩子开心极了。<br>
<img src="https://cafra.github.io//post-images/1585413369015.jpeg" alt="" loading="lazy"><br>
孩子去郑州找妈妈，房间里，孩子玩起了口红，最后小脑袋和嘴巴上都是口红，活脱脱一个小傻瓜<br>
<img src="https://cafra.github.io//post-images/1585413452276.jpeg" alt="" loading="lazy"><br>
这张时，孩子在郑州楼下的航海公园拍摄的，淑女了很多。<br>
<img src="https://cafra.github.io//post-images/1585413509397.jpeg" alt="" loading="lazy"><br>
19年我腰椎骨折，恰逢疫情，在丈母娘家过年了，孩子已经会自己刷牙，自己洗碗了。趁着吃饭时，给孩子拍了张照片。<br>
未完待续。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我在超原子的2019年]]></title>
        <id>https://cafra.github.io/post/wo-zai-chao-yuan-zi-de-2019-nian/</id>
        <link href="https://cafra.github.io/post/wo-zai-chao-yuan-zi-de-2019-nian/">
        </link>
        <updated>2019-12-25T01:59:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="三个词形容2019">三个词形容2019</h1>
<ul>
<li>业务发展:贷款端业务稳步推进、投资端业务飞速发展；</li>
<li>团队壮大:每个人都可以独挡一面；</li>
<li>架构升级:满足快速布局海外市场的需求；</li>
</ul>
<h1 id="与超原子的故事">与超原子的故事</h1>
<ul>
<li>从17年12月加入金融部，直到年会出发前，还在忙着项目上线；</li>
<li>18年6月开始的印尼p2p牌照申请，整个团队都拧成一股绳，通宵达旦，至今我都觉得的团队干了一件值得回忆的大事。</li>
<li>19年5月lender 活动开始发力，从6月份到9月，lender资金占系统撮合交易的75% 增长到100%，实现平台的良性运转；</li>
<li>紧接着11月就开始了新系统的研发工作，近期菲律宾市场即将开始发布，越南市场年前开发完成，这些成果，离不开团队的每一个人：宋世军、陆康、陈忠敏、刘斌、柴轮轮和平台组同学的配合。</li>
</ul>
<h1 id="新一年的展望">新一年的展望</h1>
<ul>
<li>印尼市场不断扩展新业务，成为行业翘楚；</li>
<li>新市场在菲律宾、越南、印度遍地开花，实现全球化运营；</li>
<li>系统容器化部署和弹性扩展，不断提高系统稳定性；</li>
<li>每个人都将超原子的文化融入自己的工作中，成为彼此值得信赖的战友；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工程管理硕士开始备考点滴]]></title>
        <id>https://cafra.github.io/post/mem/</id>
        <link href="https://cafra.github.io/post/mem/">
        </link>
        <updated>2019-04-19T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  终于下定决心<strong>考研</strong>了！<br>
✍️  <strong>考研</strong></p>
<pre><code> 大学时为了媳妇和孩子，放弃了考研；
 现在每天除了工作、加班；其他时间都是备考和健身；
 在孩子美好的童年，媳妇最美的时光，不能陪伴他们，希望当我获得北航MEM后，可以多陪陪家人；

</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>👏  终于下定决心<strong>考研</strong>了！<br>
✍️  <strong>考研</strong></p>
<pre><code> 大学时为了媳妇和孩子，放弃了考研；
 现在每天除了工作、加班；其他时间都是备考和健身；
 在孩子美好的童年，媳妇最美的时光，不能陪伴他们，希望当我获得北航MEM后，可以多陪陪家人；

</code></pre>
<!-- more -->
<p>提前面试准备 https://github.com/cafra/mem</p>
<p><a href="https://github.com/cafra">Github</a><br>
<a href="https://www.cnblogs.com/cz-blog/">博客</a></p>
]]></content>
    </entry>
</feed>